# Review Page

本页面为所有代码的做法与总结。

---
**0. [Fibonacci](https://github.com/Kelv1nYu/)**      Level: Easy

斐波那契数列:

递归的思想：
      
      n = 0, num = 0
      
      n = 1, num = 1
      
      n = 2, num = 1
      
      ...
      
      n = k(k > 1), f(k) = (k-1) + (k-2)
      
      n = 0, f(0) = 0
      
      n = 1, f(1) = 1
      
循环的思想：

      n = 0, num = 0
      n = 1, num = 1
      n = 2, num = 0 + 1
      
      # 主要思想为将之前计算的和直接用于下次计算，而不是再计算一次，所以一共只需要计算n-1次加法
      a = 1   # a存放较大的数
      b = 0   # b存放较小的数
      ret = 0 # ret用来暂存 a + b 的和
      
      # 开始循环，循环体内：
      ret = a + b
      b = a   # 将a的值赋给b，作为下一次计算的b
      a = ret # 将ret（a + b）的值赋给a，作为下一次计算的a

---
**1. [跳台阶](https://github.com/Kelv1nYu/)**      Level: Easy

通过枚举找规律发现:

      steps = 0, 没有可能
      steps = 1, n = 1 (1)
      steps = 2, n = 2 (1-1, 2)
      steps = 3, n = 3 (1-1-1, 1-2, 2-1)
      steps = 4, n = 5 (1-1-1-1, 2-2, 1-1-2, 1-2-1, 2-1-1)
      ....
      当台阶数大于2时，f(n) = (n-2) + (n-1)
      当台阶数等于2时，f(2) = 2
      当台阶数等于1时，f(1) = 1
      
      # 或可以逆向思考，从 n 往回跳，只能跳一步或两步，跳一步之后剩下f(n-1)种可能的跳法；跳两部之后则剩下f(n-2)种方法，所以最后也可推导出上述通式

递归的思想：
      
      n = 1, num = 1
      
      n = 2, num = 1
      
      ...
      
      n = k(k > 1), f(k) = (k-1) + (k-2)
      
      n = 1, f(1) = 1
      
      n = 2, f(2) = 2
      
循环的思想：

      n = 1, num = 1
      n = 2, num = 2
      
      # 主要思想为将之前计算的和直接用于下次计算，而不是再计算一次，所以一共只需要计算n-2次加法
      # 因为本次需从3开始计算，所以循环的范围为range(3, n + 1)或range(0, n - 2)或其他相应次数即可
      a = 2   # a存放较大的数
      b = 1   # b存放较小的数
      ret = 0 # ret用来暂存 a + b 的和
      
      # 开始循环，循环体内：
      ret = a + b
      b = a   # 将a的值赋给b，作为下一次计算的b
      a = ret # 将ret（a + b）的值赋给a，作为下一次计算的a

---
**2. [变态跳台阶](https://github.com/Kelv1nYu/)**      Level: Easy

通过枚举找规律发现:

      steps = 0, 没有可能
      steps = 1, n = 1 (1)
      steps = 2, n = 2 (1-1, 2)
      steps = 3, n = 4 (1-1-1, 1-2, 2-1, 3)
      steps = 4, n = 8 (1-1-1-1, 2-2, 1-1-2, 1-2-1, 2-1-1, 1-3, 3-1, 4)
      ....
      steps = n，f(n) = 2^(n-1)
      
      可直接使用pow(2, n-1)得出结果
      
逆向思维推导公式：

      f(n) = f(n-1) + f(n-2) + ... +f(1)
      f(n-1) = f(n-2) + f(n-3) + ... + f(1)
      ...
      # 可以得出通式(n > 1)
      f(n) = 2f(n-1)
      f(1) = 1

递归的思想：
      
      n = 1, num = 1
      
      ...
      
      n = k(k > 1), f(k) = 2(k-1)
      
      n = 1, f(1) = 1
      
循环的思想：

      n = 1, num = 1
      
      # 主要思想为将之前计算的乘积直接用于下次计算，而不是再计算一次，所以一共只需要计算n-1次乘法
      # 因为本次需从2开始计算，所以循环的范围为range(3, n + 1)或range(0, n - 1)或其他相应次数即可
      a = 1   
      ret = 0 # ret用来暂存 2 * a 的乘积
      
      # 开始循环，循环体内：
      ret = 2 * a
      a = ret # 将ret（a * 2）的值赋给a，作为下一次计算的a

---
---
**3. [二维数组中的查找](https://github.com/Kelv1nYu/)**      Level: Easy

简单的循环嵌套：
      
      # 循环i
      for i in len(array):
      # 循环j
          for j in len(array[0]):
          # 比较值，存在返回True
      
      循环体外返回False
      
拟指针移动：
      
      假设指针最开始指向右上角，即i = 0，j = len(array[0]) - 1的位置
      # 开始while循环，条件为 i < len(array) 和 j >= 0, 即行和列不超出数组边界
      # 进行值的比较：
      if target == array[i][j]:
          return True
      elif target < array[i][j]:
          j -= 1                  # 当目标值小于当前值时，需要指针左移，故 j - 1
      else:
          i += 1                  # 反之，当目标值大于当前值时，需要指针下移，故 i + 1，下移指向下移列最后一个值然后，实现每一行都从最后一个值往前进行判断
      
---
